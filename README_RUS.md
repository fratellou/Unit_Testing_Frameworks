## Unit_testing_frameworks

1. Написать стековый калькулятор, который принимает в качестве аргумента командной строки имя файла, содержащего команды. Реализовать набор модульных тестов, покрывающих функционал калькулятора. 
2. Реализовать набор модульных тестов, покрывающих функционал https://github.com/fratellou/NoSQL-database, используя на Google Test. 

## Оглавление

1. [Задание 1](#задание-1) \
    1.1 [Задание 1. Теория](#задание-1-теория) \
    1.2 [Задание 1. Код](#задание-1-код)
2. [Задание 2](#задание-2) \
    2.1 [Задание 2. Теория](#задание-2-теория) \
    2.2 [Задание 2. Код](#задание-2-код)

# Задание 1

Написать стековый калькулятор, который принимает в качестве аргумента командной строки имя файла, содержащего команды. Если аргумента нет, то использовать стандартный поток ввода для чтения команд. Использовать вещественные числа.  
Реализовать набор модульных тестов, покрывающих функционал калькулятора. 
В программе реализовать следующий набор команд: 
- \# - строка с комментарием. 
- POP, PUSH — снять/положить число со/на стек(а). 
- \+ , - , * , /, SQRT – арифметические операции. Используют один или два верхних элемента стека, изымают их из стека, помещая результат назад PRINT — печать верхнего элемента стека (без удаления). 
- DEFINE — задать значение параметра. В дальнейшем везде использовать вместо параметра это значение.  
 
Пример (должно вывести 2): 
> DEFINE a 4 
>
> PUSH a SQRT  
>
> PRINT  
>

Методические указания: 
Создание команд рекомендуется реализовать посредством шаблона проектирования «фабричный метод». 
Аргументы команде (тем у которых есть аргументы) на исполнение можно передавать в виде списка объектов, команда сама должна уметь интерпретировать свои аргументы 
Содержимое стека и список (лучше ассоциативный контейнер std::map<std::string, double>) определенных именованных параметров передавать команде в виде специального объекта — контекста исполнения  
Разработать иерархию исключений, которые будут выбрасывать команды при исполнении. В случае возникновения исключения — выводить информацию об ошибке и продолжать исполнение программы (из файла или команд вводимых с консоли). 
Для реализации модульных тестов использовать Google Test Framework

## Задание 1. Теория

Подробное объснение фабричного метода можно найти в репозитории https://github.com/fratellou/Factory_method.

Установка Google Test Framework на Ubuntu:

> sudo apt-get install libgtest-dev libgmock-dev # для ubuntu 20
>
> sudo apt-get install google-mock # для ubuntu 18

После их установки в каталоге с заголовочными файлами /usr/include/ появятся папки gtest и gmock. Однако, для полноценной работы фреймворку нужна еще поддержка многопоточности. Добавим ее:

> sudo apt-get install libtbb-dev

Для компиляции понадобится установить пакет cmake:

> sudo apt-get install cmake

Когда вы установили чуть выше libgtest-dev - в вашу систему также добавились исходники googletest и googlemock, которые можно найти в директории /usr/src/googletest/.

Идем туда:

> cd /usr/src/googletest/

Создаем каталог для сборки и переходим в него:

> sudo mkdir build
>

> cd build
>

В этом каталоге запускаем команду:

> sudo cmake ..

Две точки рядом с cmake означают, что нужно искать файл сценария CMakeLists.txt в родительском каталоге. Эта команда сгенерирует набор инструкций для компиляции и сборки библиотек gtest и gmock. После чего останется выполнить:

> sudo make

Если все пройдет успешно, то будет создан новый каталог lib, где будут находится 4 файла:

`libgmock.a, libgmock_main.a, libgtest.a, libgtest_main.a`

Эти файлы содержат реализацию функционала фреймворка и их нужно скопировать в каталог к остальным библиотекам:

> sudo cp lib/* /usr/lib

*Для ubuntu 18 библиотеки будут находится в ./googlemock/ и ./googlemock/gtest/
После копирования каталог build можно удалить.

После этого можно переходить в директорию с проектом и запускать Makefile.

Для запуска юнит-тестов необходимо перейти в директорию test и запустить bash-скрипт:

> sh tester.sh

## Задание 1. Код

Класс `ExecutionContext` содержит состояние калькулятора: 
- `operandStack` - стек для хранения операндов;
- `definedParameters` отображение для хранения пользовательских параметров.

Класс `Command` - это абстрактный базовый класс, представляющий команду калькулятора. Он объявляет чисто виртуальную функцию `execute()`, которую должны реализовать производные классы. Деструктор объявлен виртуальным для правильного освобождения ресурсов.

Класс `PushCommand` - представляет команду для добавления значения в стек операндов. Принимает значение в качестве параметра и реализует функцию `execute()` для добавления значения в стек операндов.

Класс `PopCommand` представляет команду для извлечения значения из стека операндов. Реализует функцию `execute()` для проверки наличия элементов в стеке и извлечения верхнего значения.

Класс `PrintCommand` представляет команду для вывода верхнего значения стека операндов. Реализует функцию `execute()` для проверки наличия элементов в стеке и вывода верхнего значения.

Класс `DefineCommand` представляет команду для определения параметра с заданным значением. Принимает имя параметра и его значение, реализует функцию `execute()` для добавления параметра в отображение `definedParameters`.

Класс `SqrtCommand` представляет команду для вычисления квадратного корня из верхнего значения стека операндов. Проверяет наличие элементов в стеке и отрицательность операнда, реализует функцию `execute()` для выполнения операции извлечения квадратного корня.

Класс `AddCommand` представляет команду для сложения двух верхних значений стека операндов. Проверяет недостаточное количество операндов, реализует функцию `execute()` для выполнения сложения.

Класс `SubCommand` представляет команду для вычитания двух верхних значений стека операндов. Проверяет недостаточное количество операндов, реализует функцию `execute()` для выполнения вычитания.

Класс `MulCommand` представляет команду для умножения двух верхних значений стека операндов. Проверяет недостаточное количество операндов, реализует функцию `execute()` для выполнения умножения.

Класс `DivCommand` представляет команду для деления двух верхних значений стека операндов. Проверяет недостаточное количество операндов и деление на ноль, реализует функцию `execute()` для выполнения деления.

Класс `NumCommand` представляет команду для пропуска строки, начинающейся с '#'. Ничего не выполняет, служит заполнителем для комментариев.

Класс `CommandFactory` - это абстрактный базовый класс, представляющий фабрику для создания экземпляров команд. Он объявляет чисто виртуальную функцию `createCommand()`, которую должны реализовать производные классы.

Класс `PushCommandFactory` - это конкретная фабрика для создания экземпляров `PushCommand`.

Класс `PopCommandFactory` - это конкретная фабрика для создания экземпляров `PopCommand`.

Класс `PrintCommandFactory` - это конкретная фабрика для создания экземпляров `PrintCommand`.

Класс `DefineCommandFactory` - это конкретная фабрика для создания экземпляров `DefineCommand`.

Класс `SqrtCommandFactory` - это конкретная фабрика для создания экземпляров `SqrtCommand`.

Класс `AddCommandFactory` - это конкретная фабрика для создания экземпляров `AddCommand`.

Класс `SubCommandFactory` - это конкретная фабрика для создания экземпляров `SubCommand`.

Класс `MulCommandFactory` - это конкретная фабрика для создания экземпляров `MulCommand`.

Класс `DivCommandFactory` - это конкретная фабрика для создания экземпляров `DivCommand`.

Класс `NumCommandFactory` - это конкретная фабрика для создания экземпляров `NumCommand`.

Класс `Factory` предоставляет статический метод `createCommand()`, который использует соответствующую фабрику на основе имени команды, возвращая экземпляр соответствующей команды.

`main()`- главная функция программы. Проверяет количество аргументов командной строки: 
- если передан один аргумент, то вызывается функция `executeCommandsFromFile()` для выполнения команд из файла; 
- если нет аргументов, вызывается `executeCommandsFromStdin()` для выполнения команд из стандартного ввода.

`executeCommandsFromFile()` - функция выполняет команды, считывая их из файла с указанным именем. Если файл не может быть открыт, выводится сообщение об ошибке.

`executeCommandsFromStdin()` - функция выполняет команды, считывая их из стандартного ввода. Ввод продолжается до тех пор, пока не введена команда "exit".

`processCommand()` - функция обрабатывает строку команды. Она разбивает строку на токены, создает экземпляр команды с использованием фабрики и выполняет эту команду с глобальным `ExecutionContext`. Если произойдет исключение, сообщение об ошибке выводится в стандартный поток ошибок (cerr).

# Задание 2

1. Реализовать классы с базовым набором операций (private, public):
- массив;
- список (односвязный, двусвязный);
- очередь;
- стек;
- хеш таблица;
- бинарное дерево.
2. Реализовать класс «Стек» с базовым набором операций (private, public).
3. Реализовать покрытие тестами Google test (не менее 90%).

## Задание 2. Теория

Полное объяснение структур находится в репозитории https://github.com/fratellou/NoSQL-database.

## Задание 2. Код

Класс Array:
`add()`- добавляет элемент в конец массива.
`insert()` - вставляет элемент в указанный индекс массива.
`removeLast()` - удаляет последний элемент из массива.
`removeAtIndex()` - удаляет элемент по указанному индексу из массива.
`get()` - получает значение по указанному индексу в массиве.
`change()` - изменяет значение по указанному индексу в массиве.
`search()` - ищет элемент в массиве и возвращает его индекс.

Класс Double Linked List:
`addToBeginning()` - добавляет элемент в начало списка.
`addToEnd()` - добавляет элемент в конец списка.
`removeByValue()` - удаляет первое вхождение указанного значения из списка.
`removeFromEnd()` - удаляет последний элемент из списка.
`insertAtIndex()` - вставляет элемент по указанному индексу в списке.
`removeFromBeginning()` - удаляет первый элемент из списка.
`removeAtIndex()` - удаляет элемент по указанному индексу из списка.
`search()` - ищет значение в списке и возвращает его индекс.

Класс Hash Table:
`set()` - вставляет или обновляет пару ключ-значение в хэш-таблицу.
`del()` - удаляет пару ключ-значение из хэш-таблицы.
`get()` - возвращает значение, связанное с указанным ключом в хэш-таблице.

Класс Linked List:
`add()` - добавляет элемент в начало списка.
`insert()` - вставляет элемент по указанному индексу в списке.
`remove()` - удаляет первый элемент из списка.
`removeByIndex()` - удаляет элемент по указанному индексу из списка.
`removeByValue()` - удаляет первое вхождение указанного значения из списка.
`search()` - ищет значение в списке и возвращает его индекс.
`print()` - выводит элементы списка на экран.

Класс Queue:
`push()` - добавляет элемент в конец очереди.
`pop()` - удаляет и возвращает первый элемент из очереди.

Класс Stack:
`push()` - добавляет элемент на вершину стека.
`pop()` - удаляет и возвращает элемент с вершины стека.

Класс Tree:
`add()` - добавляет узел с заданным ключом в дерево.
`search()` - ищет узел с заданным ключом в дереве.
`succ()` - возвращает преемника узла в дереве.
`min()` - возвращает узел с минимальным ключом в дереве.
`del()` - удаляет узел с заданным ключом из дерева.
`transplant()` - заменяет одно поддерево другим в дереве.
`print()` - выводит содержимое дерева на экран в структурированном формате.

>
> fratellou, 2024