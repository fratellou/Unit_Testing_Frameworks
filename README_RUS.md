## Unit_testing_frameworks

1.	Реализовать unit-testing 
2.	Написать стековый калькулятор, который принимает в качестве аргумента командной строки имя файла, содержащего команды. Если аргумента нет, то использовать стандартный поток ввода для чтения команд. Использовать вещественные числа.  
Реализовать набор модульных тестов, покрывающих функционал калькулятора. 
В программе реализовать следующий набор команд: 
- \# - строка с комментарием. 
- POP, PUSH — снять/положить число со/на стек(а). 
- \+ , - , * , /, SQRT – арифметические операции. Используют один или два верхних элемента стека, изымают их из стека, помещая результат назад PRINT — печать верхнего элемента стека (без удаления). 
- DEFINE — задать значение параметра. В дальнейшем везде использовать вместо параметра это значение.  
 
Пример (должно вывести 2): 
> DEFINE a 4 
> PUSH a SQRT  
> PRINT  
>

Методические указания: 
Создание команд рекомендуется реализовать посредством шаблона проектирования 
«фабричный метод» (http://ru.wikipedia.org/wiki/Фабричный_метод_(шаблон_проектирования)). 
Аргументы команде (тем у которых есть аргументы) на исполнение можно передавать в виде списка объектов, команда сама должна уметь интерпретировать свои аргументы 
Содержимое стека и список (лучше ассоциативный контейнер std::map<std::string, double>) определенных именованных параметров передавать команде в виде специального объекта — контекста исполнения  
Разработать иерархию исключений, которые будут выбрасывать команды при исполнении. В случае возникновения исключения — выводить информацию об ошибке и продолжать исполнение программы (из файла или команд вводимых с консоли). 
Для реализации модульных тестов использовать Google Test Framework

3. Реализовать набор модульных тестов, покрывающих функционал ЛР3, используя на выбор C++ Unit Testing Frameworks: 
1.	Google Test 
2.	CxxTest 
3.	Boost Test Library 

